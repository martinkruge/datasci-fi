---
title: "Assignment 1 // Getwine Recommender System"
author: "Martin Kruger (KRGMAR043)"
date: '`r format(Sys.Date())`'
output:
  pdf_document:
    latex_engine: xelatex
    fig_caption: yes
    keep_tex: yes
    highlight: haddock
    toc_depth: 2    
header-includes: 
  \usepackage{float}
  \usepackage[section]{placeins}
  \usepackage{booktabs}
  \usepackage{graphicx}
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo=TRUE,tidy=TRUE,fig.pos = 'H')

library(xtable)
options(xtable.floating=TRUE)
options(xtable.timestamp="")
options(xtable.comment=FALSE)

```


## 1. Introduction

The aim of this project is to build a recommender system for Getwine, an online wine retailer (http://getwine.co.za/). The function of the recommender system is to recommend to a user wines that, on the basis of his or her past purchases, they might like to buy in the future. 


## 2. Data Description

The data that was provided for the project consists of all purchase orders made by 1000 randomly selected Getwine users in 2017. A purchase order is a single “delivery” of wine to a user. A single order can consist of any number and selection of bottles of wine, but usually consists of 12 or more bottles. 
\ 

The data has been provided in two files:

```{r data_load, include=FALSE}

#rm(list=ls()) # Clean up environment

library(tidyverse)
library(tidytext)
library(stringr)
library(lubridate)

set.seed(790904)


# Load getwines order data from .csv
orders <- as.tibble(read.csv('./assignments/data/orders.csv', header = T, sep = ','))
order.items <- as.tibble(read.csv('./assignments/data/order-items.csv', header = T, sep = ','))

# Fix date format to only include date and not time
orders$date_purchased <- format(as.Date(orders$date_purchased),"%Y/%m/%d")
orders$customers_dob <- format(as.Date(orders$customers_dob),"%Y/%m/%d")

```


1. **orders.csv**: Each row in this file constitutes a single customer order. A single order may consist of any number of bottles of wine. The order is identified by a unique key `orders_id` that can be used to identify the wines that were purchased in the accompanying file *order-items.csv*. 

- Other variables are:  
      + Customer’s gender 
      + Customer’s date of birth 
      + Customer’s location 
      + Date of purchase 
      + Payment method 
      + Monetary value of the order 

\ 

```{r, echo=FALSE, results="asis", out.width='90%', fig.pos="H", fig.align='center'}
tab.rescale <- xtable(head(orders), caption = 'Layout of the orders table.')
print(tab.rescale, scalebox=0.7, include.rownames = TRUE, include.colnames = TRUE, comment = FALSE,  type = 'latex')

```

2. **order-items.csv**
Contains the wines bought in each order, together with the quantity bought and the price per bottle. 
\ 


```{r, echo=FALSE, results="asis", out.width='90%', fig.pos="H", fig.align='center'}
tab.rescale <- xtable(head(order.items), caption = 'Layout of the order-items table.')
print(tab.rescale, scalebox=0.8, include.rownames = TRUE, include.colnames = TRUE, comment = FALSE,  type = 'latex')

```

\pagebreak
\newpage

## 3. Exploration & Cleaning

```{r all_products, include=FALSE}

# Total list of products
all.products <- order.items %>% select(products_name) %>% unique()
#dim(all.products) # 336
```


The `order.items` dataset was used to determine the list of products ordered by customers during the period of the transaction history that was provided. The complete list of products in the `products_name` field consisted of `r dim(all.products)[1]` items.

```{r filtered_products, message=FALSE, include=FALSE}

# List of unique products - filter personalised and assorted cases
# Negative values (discount)
clean.products <- order.items %>% 
  filter(products_price >= 0) %>%  
  select(products_name) %>% 
  filter(!str_detect(products_name, 'Personalised Mixed Case')) %>%
  filter(!grepl('TOP SELLING.*Case', products_name)) %>% 
  filter(!str_detect(products_name, 'Assorted')) %>% 
  filter(!str_detect(products_name, "Budget White")) %>% 
  filter(!str_detect(products_name, "Budget Red")) %>% 
  filter(!str_detect(products_name, 'Personalised Label')) %>% 
  filter(!str_detect(products_name, 'Gift Voucher')) %>% 
  filter(!grepl('Samarie Smith se.*: Versnit-wynklub', products_name)) %>% 
  filter(!str_detect(products_name, "LOUIS COETZEE's CRAFT BEER Case")) %>% 
  filter(!str_detect(products_name, 'Brewery')) %>% 
  filter(!str_detect(products_name, "JORDAN Lifestyle Case 12-pack")) %>% 
  filter(!str_detect(products_name, "GETWINE Glase")) %>% 
  filter(!str_detect(products_name, "30 bottles Rooiberg Brut Sparkling")) %>% 
  filter(!str_detect(products_name, "Devil's Peak Pale Ale 340ml")) %>% 
  filter(!str_detect(products_name, "Devil's Peak Alpha Ginger Cider 340ml")) %>% 
  filter(!str_detect(products_name, "Devil's Peak The King's Blockhouse IPA 340ml")) %>% 
  filter(!str_detect(products_name, "Devil's Peak Alpha Lager 340ml")) %>% 
  filter(!str_detect(products_name, "Devil's Peak Lager 340ml")) %>% 
  filter(!str_detect(products_name, "Dragon Fiery Ginger Beer 330ml")) %>% 
  filter(!str_detect(products_name, "Citizen Saboteur English IPA 440ml")) %>%
  unique()
#dim(clean.products)  # 285

filtered.products <- anti_join(all.products, clean.products, by=c('products_name')) %>% unique() %>% arrange(products_name)
#filtered.products # 51
```

Inspection of the product names pointed out `r dim(filtered.products)[1]` items that can be excluded from the final dataset used for modelling of the recommender system as they are either not related to wine purchases or they contain a mixed variety of wines. The complete list of products that were excluded are listed in table 5. The remaining list of `r dim(clean.products)[1]` products were considered for modeling of a recommender system. 
\ 


Included in the list of products are items that are sold in bulk quantities, like boxes containing 6 bottles of wine.

```{r data_explore, echo=FALSE, message=FALSE, results="asis", out.width='90%', fig.pos="H", fig.align='center'}

# Cases with multiple bottles
bulk.items <- order.items %>% semi_join(clean.products) %>%
  extract( products_name, into = c("product_count"), regex = "(\\d+)\\sbottles", remove = FALSE) %>%
  filter(!is.na(product_count)) %>%
  select(products_name) %>% 
  unique()

tab.rescale <- xtable(bulk.items, caption = 'Bulk sold products.')
print(tab.rescale, scalebox=0.8, include.rownames = TRUE, include.colnames = TRUE, comment = FALSE,  type = 'latex', table.placement="H")

```

These bulk quantity items can be handled in different ways. The easiest option would be to exclude them from the data completely, but it might have an undesirable effect on our recommender system. In this case the initial option explored was to include them with a re-calculated volume measure based on box size multiplied by the quantity ordered. 

\ 

Further investigation pointed out that the largest portion of these bulk purchases belong to a single customer (`customers_id` 33266). It was decided to completely remove this customer from the dataset as it seems he/she can be considered as a bulk consumer and might cause a skewed effect on the recommender model. The single remaining bulk purchase of `customers_id` 16686 was included as a normal type consumer. 
\ 

```{r bulk_quantities, echo=FALSE, message=FALSE, results="asis", out.width='90%', fig.pos="H", fig.align='center'}

# Add total count of bottles per order - take into account cases with multiple bottles
# Only keep the cleaned-up list of products
clean.order.items <- order.items %>% semi_join(clean.products) %>%
  extract( products_name, into = c("product_count"), regex = "(\\d+)\\sbottles", remove = FALSE) %>%
  mutate(product_count = as.integer(ifelse(is.na(product_count), 1, product_count))) %>%
  mutate(products_total_quantity = product_count * products_quantity) 

# Products where product_count > 1 are bulk options
bulk.order.items <- clean.order.items %>% filter(product_count > 1)

# All orders that included bulk items
bulk.orders <- orders %>%
  select(-customers_gender,-customers_dob, -countries_name, -payment_method) %>%
  inner_join(bulk.order.items) %>%
  select(-product_count, -products_total_quantity)

# Orders of customer that only buys in bulk
bulk.orders.customer <- orders %>% inner_join(clean.order.items) %>% filter(customers_id == 33266)


# Keep only order items based on the filtered product list, and remove the bulk consumer
clean.order.items <- anti_join(clean.order.items, bulk.orders.customer)

# Update factor levels
clean.order.items <- droplevels(clean.order.items)
clean.products <- droplevels(clean.products)

# Print out table with bulk order details
tab.rescale <- xtable(bulk.orders, caption = 'Details of all orders that contain bulk items.')
print(tab.rescale, scalebox=0.7, include.rownames = FALSE, include.colnames = TRUE, comment = FALSE,  type = 'latex', table.placement="H")
```

\ 

```{r filtered_items, echo=FALSE, message=FALSE, results="asis", out.width='90%', fig.pos="!H", fig.align='center'}
tab.rescale <- xtable(filtered.products, caption = 'Non wine-sale related products that were removed.')
print(tab.rescale, scalebox=0.8, include.rownames = TRUE, include.colnames = TRUE, comment = FALSE,  type = 'latex', table.placement="H")

```

\pagebreak
\newpage


## 4. Recommender System

Building a recommender system for Getwines we have a couple of options for the type of recommender system we can use.
The main types of recommender systems are:

  1. Collaborative filtering: The algorithms are based on information about similar users or similar items. 
    The two sub-branches are as follows: 

    i) Item-based collaborative filtering: This recommends to a user the items that are most similar to the user's purchases. 
    ii) User-based collaborative filtering: This recommends to a user the items that are the most preferred by similar users. 

  2. Content-based filtering: This is for each user; it defines a user profile and identify the items that match it. 
  3. Knowledge-based filtering: This is uses explicit knowledge about users and items. 
  4. Hybrid filtering: This combines different techniques. 
  5. One might also consider building a really simple recommender system that would just recommend the most popular products (that a customer hasn't ordered before) based on totals of products ordered.  

\ 

Next we will explore a couple of these options starting with the most basic. We begin by combining the data from `orders` and `order.items` in order to calculate total quantities and order frequency of each product per customer, or the totals of customers, orders and quantities per product. We will make use of the filtered list of products which is stored in `clean.order.items`.

A sample of the combined data which lists customers ranked by descending order of total quantity per product is shown in the table below. To understand the content in this table, we look at one example, customer id `5446`. This customer ordered a combined total of 30 bottles *Cloof The Very Sexy Shiraz 2014* on 3 seperate occasions. 

The histogram of total quantities per product per customer indicate that most orders contain multiples of 6 bottles per customer per product, i.e 6, 12, 18 or 24 bottles. 


```{r customer_totals, echo=FALSE, fig.align='center', fig.pos="H", message=FALSE, out.width='70%', results="asis", fig.cap="Histogram of product total quantities per customer."}

# Totals per customer per item
# (cust_id, orders_id, date_purchased)
customer.items <- orders %>% 
  select(1,5,6) %>% 
  unique() %>% 
  left_join(clean.order.items, by = "orders_id") %>%
  filter(!is.na(products_name)) %>%
  select(customers_id, orders_id, date_purchased, 
         products_name, products_total_quantity) %>%
  group_by(customers_id, products_name) %>%
  summarise(products_quantity = sum(products_total_quantity), order_count = n_distinct(date_purchased)) %>%
  group_by(customers_id) %>%
  arrange(desc(order_count), customers_id, desc(products_quantity), products_name)
  
barplot(table(customer.items$products_quantity), main="", 
     cex.axis=0.9, cex.lab=1, cex.names = 0.9, las=2, width=2,
     xlab="Total Quantity", ylab="Frequency",
     col="grey", xlim=c(0,80), ylim=c(0,2000))


tab.rescale <- xtable(head(customer.items,20), caption = 'Sample extract of customers ranked by descending order of total quantity per product.')
print(tab.rescale, scalebox=0.8, include.rownames = FALSE, include.colnames = TRUE, comment = FALSE,  type = 'latex', table.placement="H")

```

\ 

### 4.1 Total quantities per product

As first basic recommender we can recommend products based on their popularity. The popularity of products can be measured by the total quantity of each product that were ordered. The table below contains a list of products that were ordered the most by total quantity. The product *Le Bonheur Prima 2013 unlabelled* is at the top of this list with 930 bottles sold in total to a group of 108 individual customers spread over 109 seperate orders. It can be estimated that customers only buy this wine once on average each order having 8 to 9 bottles.


```{r popular_products1, echo=FALSE, message=FALSE, results="asis", out.width='70%', fig.pos="H", fig.align='center', fig.cap="Histogram of product total quantities."}

# Most popular products based on total quantity 
products_frq.total <- clean.order.items %>% left_join(select(orders,customers_id, orders_id), by="orders_id") %>%
  group_by(products_name) %>% 
  summarise(order_count = n_distinct(orders_id), 
            customer_count = n_distinct(customers_id),
            total_quantity = sum(products_total_quantity), 
            total_sales = sum(products_price*products_quantity)) %>%  
  arrange(desc(total_quantity), desc(order_count), desc(total_sales))


hist(products_frq.total$total_quantity, breaks = 100, main="", 
     cex.axis=0.9, cex.lab=1, xlim=c(0,1000),
     xlab="Total Quantity", col="grey")


tab.rescale <- xtable(head(products_frq.total, 10), caption = 'Most popular products based on total quantity ordered.')
print(tab.rescale, scalebox=0.8, include.rownames = TRUE, include.colnames = TRUE, comment = FALSE,  type = 'latex', table.placement="H")

#orders %>% filter(orders_id == 153597)
#order.items %>% filter(orders_id == 153597)
```


### 4.2 Number of orders containing a product 

Another method might be to measure popularity based on the number of orders that contained each product. The top product in this scenario is *Knorhoek Shiraz/Cabernet Franc/Cabernet Sauvignon 2015* that had a total quantity ordered of 909 bottles by 112 individual customers spread over 116 unique orders. This means on average a customer orders this wine only once and each order usually contains 7 to 8 bottles. 


```{r popular_products2, echo=FALSE, message=FALSE, results="asis", out.width='70%', fig.pos="H", fig.align='center', fig.cap="Histogram of product order counts."}

# Most popular products based on order count 
products_frq.ordercount <- clean.order.items %>% left_join(select(orders,customers_id, orders_id), by="orders_id") %>%
  group_by(products_name) %>% 
  summarise(order_count = n_distinct(orders_id), 
            customer_count = n_distinct(customers_id),
            total_quantity = sum(products_total_quantity), 
            total_sales = sum(products_price*products_quantity)) %>%  
  arrange(desc(order_count), desc(total_quantity), desc(total_sales))

hist(products_frq.ordercount$order_count, breaks = 100, main="", 
     cex.axis=0.9, cex.lab=1,
     xlab="Order Count", col="grey")

tab.rescale <- xtable(head(products_frq.ordercount, 10), caption = 'Most popular products based on order count.')
print(tab.rescale, scalebox=0.8, include.rownames = TRUE, include.colnames = TRUE, comment = FALSE,  type = 'latex', table.placement="H")
```


### 4.3 Number of unique customers per product 

Another method might be to measure popularity based on the number of unique customers that ordered each product. The results of this method is very similar to the previous measure that ranked products by the number of orders containing each product as most customers ordered a particular wine only once.

Based on this measure the product ranking of the Top 10 wines remains similar, except in positions 3 and 4 *Raka Spliced 2014* and *Nitida Roxia Sauvignon Blanc 2016* swapped positions.


```{r popular_products3, echo=FALSE, message=FALSE, results="asis", out.width='70%', fig.pos="H", fig.align='center', fig.cap="Histogram of unique customer counts per product."}

# Most popular products based on customer count 
products_frq.custcount <- clean.order.items %>% left_join(select(orders,customers_id, orders_id), by="orders_id") %>%
  group_by(products_name) %>% 
  summarise(order_count = n_distinct(orders_id), 
            customer_count = n_distinct(customers_id),
            total_quantity = sum(products_total_quantity), 
            total_sales = sum(products_price*products_quantity)) %>%  
  arrange(desc(customer_count), desc(order_count), desc(total_quantity), desc(total_sales))

hist(products_frq.custcount$customer_count, breaks = 100, main="", 
     cex.axis=0.9, cex.lab=1, xlim=c(0,120),
     xlab="Customer Count", col="grey")


tab.rescale <- xtable(head(products_frq.custcount, 10), caption = 'Most popular products based on customer count.')
print(tab.rescale, scalebox=0.8, include.rownames = TRUE, include.colnames = TRUE, comment = FALSE,  type = 'latex', table.placement="H")

```

### 4.4 Regular customers 

The next method considered was to base popularity on the number of orders placed by customers, hoping that customers place multiple orders and products would be repeated from one order to the next. This once again was not the case as most customers ordered wine only once. In 737 cases out of the 839 total customers only one order was placed, in 90 cases two orders and in 10 cases 3 orders.

In the case of the top customer id `25301` on the list, the individual ordered 10 different products spread over 3 orders. The last few customers on the list which had 3 orders in total only ordered 2 to 3 different products during 3 occasions which means for those very few individuals there was repetition of products. 


```{r regular_customers, echo=FALSE, message=FALSE, results="asis", out.width='70%', fig.pos="H", fig.align='center', fig.cap="Histogram of order counts per customer."}

# Regular customers
customers_frq <- clean.order.items %>% left_join(select(orders, customers_id, orders_id), by="orders_id") %>% 
  group_by(customers_id) %>% 
  summarise(order_count = n_distinct(orders_id), 
            product_count = n_distinct(products_name),
            total_quantity = sum(products_total_quantity),
            total_sales = sum(products_price*products_quantity)) %>%  
  arrange(desc(order_count), desc(product_count), desc(total_sales))

barplot(table(customers_frq$order_count), main="", 
     cex.axis=0.9, cex.lab=1, cex.names=0.9, xlim=c(0,4), ylim=c(0,800),
     ylab="Frequency", xlab="Order Count", col="grey")

#table(customers_frq$order_count)

tab.rescale <- xtable(head(customers_frq,10), caption = 'Most regular customers.')
print(tab.rescale, scalebox=0.8, include.rownames = TRUE, include.colnames = TRUE, comment = FALSE,  type = 'latex', table.placement="H")

```

\ 


### 4.5 User-based Collaborative Filtering

The results from the methods in the previous sections indicate that recommendations based purely on quantities and frequency  of orders will not be very successfull. A more sophisticated method is needed that will also capture the preferences of customers based on their *rating* of products, or their similarity meaning customers that have "the same" buying habits and product preferences than another.

We will therefore be building our recommender system based on *User-based Collaborative Filtering (UBCF)*. UBCF is based on the relationship between customers and products, with no information about the customer or the product required. All that is needed is a rating of some kind for each customer/product interaction that occurred.  
\ 

There are two kinds of information for this type of interaction: *explicit* and *implicit* :  

- Explicit: A score, like a rating, vote or a like  
- Implicit: Not as obvious in terms of preference, but implicitly gives an indication of such as a click, view, or a purchase.   

\ 

We have transactional data that tells us which products, how much of each product, and when the purchases were made. Our dataset does not contain any explicit measures stating how much a user *rates* or *likes* a particular product. We therefore have to make use of some kind of *implicit measure*, like the *amount purchased* or *frequency of buying* to deduce a popularity index.


```{r ordered_products, eval=FALSE, include=FALSE}
# First attempt - look at items ordered
ordered_products <- customer.items %>% 
  select(customers_id, products_name, products_quantity, order_count) %>%
  complete(customers_id, products_name) %>%
  mutate(ordered = ifelse(is.na(products_quantity), 0, 1)) %>%
  mutate(quantity = ifelse(is.na(products_quantity), 0, products_quantity)) %>%
  mutate(count = ifelse(is.na(order_count), 0, order_count)) %>%
  select(-products_quantity, -order_count)

```

```{r save_data, eval=FALSE, include=FALSE}
save(list = ls(), file = "./assignments/output/getwine_recommender.RData") 
```

```{r load_data, include=FALSE}
load(file = "./assignments/output/getwine_recommender.RData")
```
\ 

#### 4.5.1 Ratings matrix

In order to build a CF recommender we need to reshape the customer vs product ratings data into a `[839x279]` matrix containing all customers as rows and all products as columns, i.e. from "long" format to "wide" format.

For exploratory purposes 3x implicit rating measure matrixes were created, i.e. one matrix for
- Biniarised orders indicating if a product was ordered or not, another for
- Total quantity of a product ordered, and another for the
- Count of times a product was ordered.

At this point it is not clear which measure(s) to use as implicit rating(s) that would capture customer similarity the best. We will hopefully be able to determine the best option for this use case, by analyzing results from the 3 test cases.

```{r rating_matrix, echo=FALSE}
#------------------------------------------------------------------
# 1. Use biniarised value as measure  - mark products ordered with 1=yes, NA=no
ordered_products_wide.order <- ordered_products %>%
  select(customers_id, products_name, ordered) %>%
  spread(key = products_name, value = ordered)

sorted_my_customers.order <- as.character(unlist(ordered_products_wide.order[,1]))
ordered_products_wide.order <- as.matrix(ordered_products_wide.order[,-1])
row.names(ordered_products_wide.order) <- sorted_my_customers.order

#------------------------------------------------------------------
# 2. Use quantity as measure of product use
ordered_products_wide.quantity <- ordered_products %>%
  select(customers_id, products_name, quantity) %>%
  spread(key = products_name, value = quantity)

sorted_my_customers.quantity <- as.character(unlist(ordered_products_wide.quantity[,1]))
ordered_products_wide.quantity <- as.matrix(ordered_products_wide.quantity[,-1])
row.names(ordered_products_wide.quantity) <- sorted_my_customers.quantity

#------------------------------------------------------------------
# 3. Use order count as measure of product use
ordered_products_wide.count <- ordered_products %>%
  select(customers_id, products_name, count) %>%
  spread(key = products_name, value = count)

sorted_my_customers.count <- as.character(unlist(ordered_products_wide.count[,1]))
ordered_products_wide.count <- as.matrix(ordered_products_wide.count[,-1])
row.names(ordered_products_wide.count) <- sorted_my_customers.count
#------------------------------------------------------------------

```

#### Similarity measures

We need to compare all customers with each other in order to determine their similarity. There are various options of similarity measures to use.

The measures used most often for Colaborative Filtering systems are: 
- Euclidean distance 
- Cosine similarity 
- Pearson correlation coefficient 
- Jaccard coefficient 
- Tanimoto coefficient 

We will make use of **Cosine** similarity to measure customer similarity. 

```{r cosine_similarity, include=FALSE}
# cosine similarity function
cosine_sim <- function(a,b){crossprod(a,b)/sqrt(crossprod(a)*crossprod(b))}

```



#### 4.5.2 Similarity matrix

We populate 3x similarity matrix's to store the customer cosine similarity between all customers.

```{r similarity_matrix, echo=FALSE}
#for (i in 1:ncol(data.germany.ibs)){
#   data.germany.ibs.similarity[,i] = apply(radio_data, 2, cosine_sim, y=as.matrix(data.germany.ibs)[,i])
#}


#------------------------------------------------------------------
# 1. Similarity matrix based on product ordered or not
customer_similarities.order <- matrix(0, nrow = nrow(customers_frq), ncol = nrow(customers_frq))
for(i in 1:(nrow(customers_frq)-1)) {
  for(j in (i+1):nrow(customers_frq)){
    customer_similarities.order[i,j] <- cosine_sim(ordered_products_wide.order[i,], ordered_products_wide.order[j,])
  }
}
customer_similarities.order <- customer_similarities.order + t(customer_similarities.order)

diag(customer_similarities.order) <- NA
row.names(customer_similarities.order) <- row.names(ordered_products_wide.order)
colnames(customer_similarities.order) <- row.names(ordered_products_wide.order)

customer_similarities.order[which(customer_similarities.order == 0)] <- NA

#------------------------------------------------------------------
# 2. Similarity matrix based on quantities per product
customer_similarities.quantity = matrix(0, nrow = nrow(customers_frq), ncol = nrow(customers_frq))
for(i in 1:(nrow(customers_frq)-1)) {
  for(j in (i+1):nrow(customers_frq)){
    customer_similarities.quantity[i,j] <- cosine_sim(ordered_products_wide.quantity[i,], ordered_products_wide.quantity[j,])
  }
}
customer_similarities.quantity <- customer_similarities.quantity + t(customer_similarities.quantity)

diag(customer_similarities.quantity) <- NA
row.names(customer_similarities.quantity) <- row.names(ordered_products_wide.quantity)
colnames(customer_similarities.quantity) <- row.names(ordered_products_wide.quantity)

customer_similarities.quantity[which(customer_similarities.quantity == 0)] <- NA

#------------------------------------------------------------------
# 3. Similarity matrix based on order count per product
customer_similarities.count = matrix(0, nrow = nrow(customers_frq), ncol = nrow(customers_frq))
for(i in 1:(nrow(customers_frq)-1)) {
  for(j in (i+1):nrow(customers_frq)){
    customer_similarities.count[i,j] <- cosine_sim(ordered_products_wide.count[i,], ordered_products_wide.count[j,])
  }
}
customer_similarities.count <- customer_similarities.count + t(customer_similarities.count)
diag(customer_similarities.count) <- NA
row.names(customer_similarities.count) <- row.names(ordered_products_wide.count)
colnames(customer_similarities.count) <- row.names(ordered_products_wide.count)

customer_similarities.count[which(customer_similarities.count == 0)] <- NA

#------------------------------------------------------------------

library(recommenderlab)

affinity.data <- customer_similarities.order
affinity.matrix <- as(affinity.data,"realRatingMatrix")


affinity.matrix@data
```


#### 4.5.3 Recommendation matrix

Do we want to recommend wines purchased before? 
This is a business case decision.

In this case we will recommend wines not ordered before.

```{r user_recommendation, include=FALSE}
# function to generate a recommendation for any user
user_based_recommendations <- function(user, user_similarities, ordered_products){
  
  # turn into character if not already
  user <- ifelse(is.character(user),  user,as.character(user))
  
  # get scores
  user_scores <- data.frame(title = colnames(ordered_products), 
                            score = as.vector(user_similarities[user,] %*% ordered_products), 
                            ordered = ordered_products[user,])
  
  # sort unordered products by score and remove the 'ordered' column
  user_recom <- user_scores %>% 
    filter(ordered == 0) %>% 
    arrange(desc(score)) %>% 
    select(-ordered) 
  
  return(user_recom)
}
```


Recommendations for all users with `lapply`


```{r, eval=FALSE, include=FALSE}
# 1. Biniarised "did/didn't order the product" based recommendations
lapply(sorted_my_customers.order, user_based_recommendations, customer_similarities.order, ordered_products_wide.order)


# 2. Quantity based recommendations
lapply(sorted_my_customers.quantity, user_based_recommendations, customer_similarities.quantity, ordered_products_wide.quantity)


# 3. Order count based recommendations
lapply(sorted_my_customers.count, user_based_recommendations, customer_similarities.count, ordered_products_wide.count)

```


\pagebreak 
\newpage

## 5. Conclusion 

TBD


## 6. References  

[1] Yifan Hu: Collaborative Filtering for Implicit Feedback Datasets. [link](http://yifanhu.net/PUB/cf.pdf)  
[2] Jesse Steinweg-Woods: A Gentle Introduction to Recommender Systems with Implicit Feedback. [link](https://jessesw.com/Rec-System/)  
[3] R-bloggers: Matrix factorization. [link](https://www.r-bloggers.com/matrix-factorization/)  
[4] CRAN-R NNLM: A package For Fast And Versatile Nonnegative Matrix Factorization. [link](https://cran.r-project.org/web/packages/NNLM/vignettes/Fast-And-Versatile-NMF.html)  
[5] Salem Marafi: Collaborative Filtering with R. [link](http://www.salemmarafi.com/code/collaborative-filtering-r/)  
[6] Suresh Kumar Gorakala: Basic recommendation engine using R. [link](http://www.dataperspective.info/2014/05/basic-recommendation-engine-using-r.html)  
[7] Bigdata Doctor: Recommender Systems 101 – A step by step practical example in R. [link](http://bigdata-doctor.com/recommender-systems-101-practical-example-in-r/)  
[8] Wikipedia: Collaborative filtering. [link](https://en.wikipedia.org/wiki/Collaborative_filtering)  
[9] Wikipedia: Cold start. [link](https://en.wikipedia.org/wiki/Cold_start)  
[10] Wikipedia: Recommender system. [link](https://en.wikipedia.org/wiki/Recommender_system)  
[11] Wikipedia: Matrix decomposition. [link](https://en.wikipedia.org/wiki/Matrix_decomposition)  
[12] Wikipedia: Non-negative matrix factorization. [link](https://en.wikipedia.org/wiki/Non-negative_matrix_factorization)  
[13] The Yhat Blog: Recommendation System in R.[link](<http://blog.yhat.com/posts/recommender-system-in-r.html)  



